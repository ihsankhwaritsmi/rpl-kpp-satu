// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package kppsatu

import (
	"context"
	"database/sql"
)

const allCommissions = `-- name: AllCommissions :many
SELECT Commissions.CommissionID,
    Commissions.CommissionDetails,
    Commissions.Price,
    Artist.ArtistName,
    Users.UserName,
    Payments.PaymentMethod
FROM Commissions
    JOIN Artist ON Commissions.Artist_ArtistID = Artist.ArtistID
    JOIN Users ON Commissions.User_UserID = Users.UserID
    JOIN Payments ON Commissions.CommissionID = Payments.CommisionID
`

type AllCommissionsRow struct {
	Commissionid      int32
	Commissiondetails string
	Price             string
	Artistname        string
	Username          string
	Paymentmethod     PaymentsPaymentmethod
}

func (q *Queries) AllCommissions(ctx context.Context) ([]AllCommissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, allCommissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllCommissionsRow
	for rows.Next() {
		var i AllCommissionsRow
		if err := rows.Scan(
			&i.Commissionid,
			&i.Commissiondetails,
			&i.Price,
			&i.Artistname,
			&i.Username,
			&i.Paymentmethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const artistLogin = `-- name: ArtistLogin :one
SELECT ArtistID,
    ArtistName
FROM Artist
WHERE ArtistEmail = ?
    AND ArtistPassword = ?
LIMIT 1
`

type ArtistLoginParams struct {
	Artistemail    string
	Artistpassword string
}

type ArtistLoginRow struct {
	Artistid   int32
	Artistname string
}

func (q *Queries) ArtistLogin(ctx context.Context, arg ArtistLoginParams) (ArtistLoginRow, error) {
	row := q.db.QueryRowContext(ctx, artistLogin, arg.Artistemail, arg.Artistpassword)
	var i ArtistLoginRow
	err := row.Scan(&i.Artistid, &i.Artistname)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM Users
WHERE UserEmail = ?
`

func (q *Queries) DeleteUser(ctx context.Context, useremail string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, useremail)
	return err
}

const getArtistNamesByCommissions = `-- name: GetArtistNamesByCommissions :many
SELECT ArtistName
FROM Artist
WHERE ArtistID IN (
        SELECT Artist_ArtistID
        FROM Commissions
    )
`

func (q *Queries) GetArtistNamesByCommissions(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getArtistNamesByCommissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artistname string
		if err := rows.Scan(&artistname); err != nil {
			return nil, err
		}
		items = append(items, artistname)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerUser = `-- name: RegisterUser :execresult
INSERT INTO Users (
        UserEmail,
        UserName,
        UserPassword
    )
VALUES (?, ?, ?)
`

type RegisterUserParams struct {
	Useremail    string
	Username     string
	Userpassword string
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerUser, arg.Useremail, arg.Username, arg.Userpassword)
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE Users
SET UserPassword = ?
WHERE UserID = ?
`

type UpdateUserPasswordParams struct {
	Userpassword string
	Userid       int32
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.Userpassword, arg.Userid)
	return err
}

const userLogin = `-- name: UserLogin :one
SELECT UserID,
    UserName
FROM Users
WHERE UserEmail = ?
    AND UserPassword = ?
LIMIT 1
`

type UserLoginParams struct {
	Useremail    string
	Userpassword string
}

type UserLoginRow struct {
	Userid   int32
	Username string
}

func (q *Queries) UserLogin(ctx context.Context, arg UserLoginParams) (UserLoginRow, error) {
	row := q.db.QueryRowContext(ctx, userLogin, arg.Useremail, arg.Userpassword)
	var i UserLoginRow
	err := row.Scan(&i.Userid, &i.Username)
	return i, err
}
